<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Andrew's Space Invaders</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            background: black;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        canvas {
            border: 2px solid white;
        }
        #gameOver {
            position: absolute;
            color: red;
            font-family: 'Press Start 2P', monospace;
            font-size: 36px;
            text-align: center;
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="gameOver">GAME OVER</div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameOverText = document.getElementById('gameOver');

        // Audio setup
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let invaderSoundIndex = 0;
        const invaderFrequencies = [150, 130, 110, 90];

        function playPlayerShot() {
            const oscillator = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(1000, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.15);
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
            oscillator.connect(gain);
            gain.connect(audioCtx.destination);
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.15);
        }

        function playInvaderMove() {
            const oscillator = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(invaderFrequencies[invaderSoundIndex], audioCtx.currentTime);
            gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
            oscillator.connect(gain);
            gain.connect(audioCtx.destination);
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.05);
            invaderSoundIndex = (invaderSoundIndex + 1) % 4;
        }

        function playInvaderDestroyed() {
            const oscillator = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.2);
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
            oscillator.connect(gain);
            gain.connect(audioCtx.destination);
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.2);
        }

        function playUfoSound() {
            const oscillator = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            oscillator.type = 'triangle';
            oscillator.frequency.setValueAtTime(1000, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.5);
            oscillator.frequency.exponentialRampToValueAtTime(1000, audioCtx.currentTime + 1.0);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            oscillator.connect(gain);
            gain.connect(audioCtx.destination);
            oscillator.start();
            return { oscillator, gain, endTime: audioCtx.currentTime + 1.0 };
        }

        function playUfoDestroyed() {
            const oscillator = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.3);
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
            oscillator.connect(gain);
            gain.connect(audioCtx.destination);
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.3);
        }

        function playGameOver() {
            const oscillator = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 1.0);
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1.0);
            oscillator.connect(gain);
            gain.connect(audioCtx.destination);
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 1.0);
        }

        // Game constants
        const GRID_SIZE = 32;
        const INVADER_ROWS = 5;
        const INVADER_COLS = 11;
        const PLAYER_SPEED = 200;
        const BULLET_SPEED = 400;
        const INVADER_SPEED = 20;
        const UFO_SPEED = 100;
        const STAR_COUNT = 50;

        // Game state
        let player = { x: canvas.width / 2 - 16, y: canvas.height - 40, width: 32, height: 16 };
        let bullets = [];
        let invaders = [];
        let ufo = null;
        let ufoSound = null;
        let stars = [];
        let score = 0;
        let level = 1;
        let lives = 3;
        let gameOver = false;
        let lastTime = 0;
        let invaderDirection = 1;
        let invaderStepTime = 0.5;
        let lastStepTime = 0;
        let ufoSpawnTime = 0;
        let ufoInterval = Math.random() * 5 + 10;

        // Sprite data
        const invaderSprites = [
            [
                [0,0,1,0,0,0,0,0,1,0,0],
                [0,0,0,1,0,0,0,1,0,0,0],
                [0,0,1,1,1,1,1,1,1,0,0],
                [0,1,1,0,1,1,1,0,1,1,0],
                [1,1,1,1,1,1,1,1,1,1,1],
                [1,0,1,1,1,1,1,1,1,0,1],
                [1,0,1,0,0,0,0,0,1,0,1],
                [0,0,0,1,1,0,1,1,0,0,0]
            ],
            [
                [0,0,1,0,0,0,0,0,1,0,0],
                [1,0,0,1,0,0,0,1,0,0,1],
                [1,0,1,1,1,1,1,1,1,0,1],
                [1,1,1,0,1,1,1,0,1,1,1],
                [1,1,1,1,1,1,1,1,1,1,1],
                [0,1,1,1,1,1,1,1,1,1,0],
                [0,0,1,0,0,0,0,0,1,0,0],
                [0,1,0,0,0,0,0,0,0,1,0]
            ]
        ];
        const invaderTypes = [
            { sprite: invaderSprites, points: 10, color: '#0f0' },
            { sprite: [[
                [0,1,1,0,0,0,0,1,1,0,0],
                [1,1,1,1,0,0,1,1,1,1,0],
                [1,1,1,1,1,1,1,1,1,1,1],
                [0,0,0,1,1,1,1,0,0,0,0],
                [0,0,1,1,0,0,1,1,0,0,0],
                [1,1,0,0,0,0,0,0,1,1,0]
            ], [
                [0,1,1,0,0,0,0,1,1,0,0],
                [1,1,1,1,0,0,1,1,1,1,0],
                [1,1,1,1,1,1,1,1,1,1,1],
                [0,0,0,1,1,1,1,0,0,0,0],
                [0,1,1,0,0,0,0,1,1,0,0],
                [0,0,1,1,0,0,1,1,0,0,0]
            ]], points: 20, color: '#ff0' },
            { sprite: [[
                [0,0,0,1,1,1,1,1,0,0,0],
                [0,1,1,1,1,1,1,1,1,1,0],
                [1,1,1,1,1,1,1,1,1,1,1],
                [1,1,1,0,0,0,0,1,1,1,1],
                [0,0,0,1,1,0,1,1,0,0,0],
                [0,0,1,1,0,0,0,1,1,0,0]
            ], [
                [0,0,0,1,1,1,1,1,0,0,0],
                [0,1,1,1,1,1,1,1,1,1,0],
                [1,1,1,1,1,1,1,1,1,1,1],
                [1,1,1,0,0,0,0,1,1,1,1],
                [0,0,1,1,0,0,0,1,1,0,0],
                [0,1,1,0,0,0,0,0,1,1,0]
            ]], points: 30, color: '#f0f' }
        ];
        const ufoSprite = [
            [0,0,1,1,1,1,1,1,1,1,0,0],
            [0,1,1,1,1,1,1,1,1,1,1,0],
            [1,1,0,1,1,1,1,1,1,0,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1],
            [0,0,1,1,1,0,0,1,1,1,0,0]
        ];
        const playerSprite = [
            [0,0,0,0,0,1,0,0,0,0,0],
            [0,0,0,0,1,1,1,0,0,0,0],
            [0,0,0,1,1,1,1,1,0,0,0],
            [0,0,1,1,1,1,1,1,1,0,0],
            [0,1,1,1,1,1,1,1,1,1,0],
            [1,1,1,1,1,1,1,1,1,1,1]
        ];

        // Initialize game
        function init() {
            initStars();
            initInvaders();
            document.addEventListener('keydown', handleInput);
            requestAnimationFrame(gameLoop);
        }

        function initStars() {
            for (let i = 0; i < STAR_COUNT; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    speed: Math.random() * 50 + 50
                });
            }
        }

        function initInvaders() {
            invaders = [];
            const typeIndex = Math.min(Math.floor((level - 1) / 2), invaderTypes.length - 1);
            const type = invaderTypes[typeIndex];
            for (let row = 0; row < INVADER_ROWS; row++) {
                for (let col = 0; col < INVADER_COLS; col++) {
                    invaders.push({
                        x: col * 48 + 100,
                        y: row * 32 + 50,
                        width: 32,
                        height: 32,
                        type: type,
                        frame: 0,
                        alive: true
                    });
                }
            }
            invaderStepTime = 0.5 / (1 + level * 0.1);
        }

        function handleInput(e) {
            if (gameOver && e.key === 'Enter') {
                resetGame();
                return;
            }
            if (e.key === 'ArrowLeft') player.dx = -PLAYER_SPEED;
            if (e.key === 'ArrowRight') player.dx = PLAYER_SPEED;
            if (e.key === ' ') {
                shootBullet();
                playPlayerShot();
            }
        }

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') player.dx = 0;
        });

        function shootBullet() {
            if (bullets.filter(b => b.player).length < 1) {
                bullets.push({
                    x: player.x + player.width / 2 - 2,
                    y: player.y,
                    width: 4,
                    height: 8,
                    dy: -BULLET_SPEED,
                    player: true
                });
            }
        }

        function update(deltaTime) {
            if (gameOver) return;

            // Update player
            player.x += (player.dx || 0) * deltaTime;
            player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));

            // Update bullets
            bullets.forEach(bullet => {
                bullet.y += bullet.dy * deltaTime;
            });
            bullets = bullets.filter(b => b.y > 0 && b.y < canvas.height);

            // Update invaders
            if (performance.now() / 1000 - lastStepTime > invaderStepTime) {
                let minX = Infinity, maxX = -Infinity, maxY = -Infinity;
                invaders.forEach(inv => {
                    if (inv.alive) {
                        minX = Math.min(minX, inv.x);
                        maxX = Math.max(maxX, inv.x + inv.width);
                        maxY = Math.max(maxY, inv.y + inv.height);
                        inv.frame = (inv.frame + 1) % 2;
                    }
                });
                if (minX < 10 || maxX > canvas.width - 10) {
                    invaderDirection *= -1;
                    invaders.forEach(inv => inv.y += 16);
                }
                invaders.forEach(inv => inv.x += invaderDirection * 16);
                playInvaderMove();
                lastStepTime = performance.now() / 1000;

                if (maxY > canvas.height - 40) {
                    gameOver = true;
                    playGameOver();
                }
            }

            // Update UFO
            ufoSpawnTime += deltaTime;
            if (!ufo && ufoSpawnTime > ufoInterval) {
                ufo = {
                    x: Math.random() < 0.5 ? -48 : canvas.width,
                    y: 20,
                    width: 48,
                    height: 16,
                    dx: Math.random() < 0.5 ? UFO_SPEED : -UFO_SPEED,
                    points: 100
                };
                ufoSound = playUfoSound();
                ufoSpawnTime = 0;
                ufoInterval = Math.random() * 5 + 10;
            }
            if (ufo) {
                ufo.x += ufo.dx * deltaTime;
                if (ufo.x < -48 || ufo.x > canvas.width + 48) {
                    ufo = null;
                    if (ufoSound) {
                        ufoSound.oscillator.stop();
                        ufoSound = null;
                    }
                } else if (ufoSound && audioCtx.currentTime > ufoSound.endTime) {
                    ufoSound.oscillator.stop();
                    ufoSound = playUfoSound();
                }
            }

            // Update stars
            stars.forEach(star => {
                star.y += star.speed * deltaTime;
                if (star.y > canvas.height) star.y -= canvas.height;
            });

            // Collision detection
            bullets.forEach(bullet => {
                if (bullet.player) {
                    invaders.forEach(inv => {
                        if (inv.alive && bullet.x < inv.x + inv.width && bullet.x + bullet.width > inv.x &&
                            bullet.y < inv.y + inv.height && bullet.y + bullet.height > inv.y) {
                            inv.alive = false;
                            bullet.y = -10;
                            score += inv.type.points;
                            playInvaderDestroyed();
                        }
                    });
                    if (ufo && bullet.x < ufo.x + ufo.width && bullet.x + bullet.width > ufo.x &&
                        bullet.y < ufo.y + ufo.height && bullet.y + bullet.height > ufo.y) {
                        ufo = null;
                        bullet.y = -10;
                        score += 100;
                        if (ufoSound) {
                            ufoSound.oscillator.stop();
                            ufoSound = null;
                        }
                        playUfoDestroyed();
                    }
                }
            });

            // Check for level completion
            if (invaders.every(inv => !inv.alive)) {
                level++;
                initInvaders();
            }

            // Enemy bullets
            if (Math.random() < 0.01 * level) {
                let aliveInvaders = invaders.filter(inv => inv.alive);
                if (aliveInvaders.length > 0) {
                    let inv = aliveInvaders[Math.floor(Math.random() * aliveInvaders.length)];
                    bullets.push({
                        x: inv.x + inv.width / 2 - 2,
                        y: inv.y + inv.height,
                        width: 4,
                        height: 8,
                        dy: BULLET_SPEED,
                        player: false
                    });
                }
            }

            // Check player hit
            bullets.forEach(bullet => {
                if (!bullet.player && bullet.x < player.x + player.width && bullet.x + bullet.width > player.x &&
                    bullet.y < player.y + player.height && bullet.y + bullet.height > player.y) {
                    lives--;
                    bullet.y = canvas.height + 10;
                    playInvaderDestroyed();
                    if (lives <= 0) {
                        gameOver = true;
                        playGameOver();
                    }
                }
            });
        }

        function drawSprite(ctx, sprite, x, y, width, height, color) {
            const pixelW = width / sprite[0].length;
            const pixelH = height / sprite.length;
            ctx.fillStyle = color;
            for (let sy = 0; sy < sprite.length; sy++) {
                for (let sx = 0; sx < sprite[0].length; sx++) {
                    if (sprite[sy][sx]) {
                        ctx.fillRect(x + sx * pixelW, y + sy * pixelH, pixelW, pixelH);
                    }
                }
            }
        }

        function draw() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw stars
            ctx.fillStyle = 'white';
            stars.forEach(star => {
                ctx.fillRect(star.x, star.y, 2, 2);
            });

            // Draw title and HUD
            ctx.font = '16px "Press Start 2P"';
            ctx.fillStyle = 'white';
            ctx.fillText("Andrew's Space Invaders", 10, 20);
            ctx.fillText(`Score: ${score}`, 10, 40);
            ctx.fillText(`Level: ${level}`, 10, 60);
            ctx.fillText(`Lives: ${lives}`, 10, 80);

            // Draw player
            drawSprite(ctx, playerSprite, player.x, player.y, player.width, player.height, '#0f0');

            // Draw invaders
            invaders.forEach(inv => {
                if (inv.alive) {
                    drawSprite(ctx, inv.type.sprite[inv.frame], inv.x, inv.y, inv.width, inv.height, inv.type.color);
                }
            });

            // Draw UFO
            if (ufo) {
                drawSprite(ctx, ufoSprite, ufo.x, ufo.y, ufo.width, ufo.height, '#f00');
            }

            // Draw bullets
            ctx.fillStyle = 'white';
            bullets.forEach(bullet => {
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            });

            // Draw game over
            if (gameOver) {
                gameOverText.style.display = 'block';
                gameOverText.style.left = `${canvas.offsetLeft + canvas.width / 2 - 100}px`;
                gameOverText.style.top = `${canvas.offsetTop + canvas.height / 2 - 24}px`;
            }
        }

        function resetGame() {
            score = 0;
            level = 1;
            lives = 3;
            gameOver = false;
            bullets = [];
            ufo = null;
            if (ufoSound) {
                ufoSound.oscillator.stop();
                ufoSound = null;
            }
            gameOverText.style.display = 'none';
            initInvaders();
        }

        function gameLoop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const deltaTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            update(deltaTime);
            draw();

            requestAnimationFrame(gameLoop);
        }

        // Resume audio context on user interaction
        document.addEventListener('click', () => {
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        });

        init();
    </script>
</body>
</html>
